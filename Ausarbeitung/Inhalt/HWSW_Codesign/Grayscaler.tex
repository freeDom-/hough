Der Grayscaler wandelt ein RGB-Bild nach \autoref{sec:umwandlung-eines-rgb-bildes-in-graustufen} in ein Graustufenbild um. Dabei erhält er als Eingabe einen Zeiger auf 32 Bit breite Pixeldaten und die Höhe und Breite des Bildes. Anschließend wird jedes Pixel durchlaufen und in Z. 16 in \autoref{lst:grayscaler} der neue Intensitätswert berechnet. Die einzelnen Werte für rot, grün und blau berechnen sich in Z. 13 - 15. Als Pixelformat wurde \emph{ARGB8888} gewählt, welches in \autoref{img:argb-format} näher dargestellt ist. Die 8 höchstwertigen Bits enthalten den Alphawert des jeweiligen Pixels, die nächsten 8 Bit den Rotwert, die folgenden 8 Bit den Grünwert und die 8 niedrigsten Bits den Blauwert.
\begin{lstlisting}[label=lst:grayscaler,caption=grayscaler]
uint8_t* grayscaler(uint32_t* input, unsigned int width, unsigned int height) {
	uint8_t *output = malloc(width * height * sizeof(uint8_t));
	
	#ifdef _OPENMP
	#pragma omp parallel for
	#endif
	// Convert image to grayscale
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
			uint8_t r, g, b;
			int index = y * width + x;
			
			r = input[index] >> 16 & 0xFF;
			g = input[index] >> 8 & 0xFF;
			b = input[index] & 0xFF;
			output[index] = 0.3*r + 0.59*g + 0.11*b;
		}
	}
	
return output;
}
\end{lstlisting}
Die for-Schleifen, in welchen das gesamte Bild durchlaufen und verarbeitet wird, werden in den Z. 4 - 6, falls \ac{OMP} verwendet wird parallelisiert.
\\
\\
Als Ausgabe liefert der Grayscaler einen Zeiger auf die neu berechneten 8 Bit breiten Pixeldaten. Es muss von der Main Methode dafür gesorgt werden, dass die erzeugten Pixeldaten auch in ein geeignetes Bild geladen werden.
\begin{figure}[htb]
	\centering
	\includegraphics[width=0.8\linewidth]{Bilder/ARGB_format.png}
	\caption[Pixelformat ARGB]{Darstellung des Pixelformates ARGB8888}
	\label{img:argb-format}
\end{figure}
