Für die Synthese des \ac{CHT} Moduls müssen verschiedene Veränderungen gegenüber der Softwareimplementierung vorgenommen werden.
\\
\\
Als Interfaces für das Modul werden das 8 Bit breite Eingabefeld mit den Daten des Eingabebildes, das Ausgabefeld, welches die gefundenen Kreise enthält und ein Zeiger auf die Anzahl der gefundenen Kreise definiert. Das Ausgabefeld ist vom Datentyp \emph{struct circle}, welcher in \autoref{lst:circle} definiert wird. %TODO: Implementierung von Zeiger in Schnittstelle erklären?
\\
\\
Zunächst muss das Feld, welches die Votingmatrix der \ac{CHT} implementiert, betrachtet werden. Dies wurde in der Softwarelösung dynamisch allokiert, um auf dem Heap gespeichert zu werden. Auf dem FPGA sollte das Akkumulatorfeld allerdings für einen effektiven Zugriff im \ac{BRAM} gespeichert werden. Für ein Bild mit einer Größe von $400 \cdot 400$ Pixeln und sieben zu durchsuchenden Radien benötigt der Akkumulator $400 \cdot 400 \cdot 7 = 1.120.000$ Elemente. In der Softwareimplementierung wurde das Feld als \emph{unsigned int} realisiert. Dieses hat auf der Zielarchitektur eine Größe von 32 Bit. Damit benötigt das Feld $32 \cdot 1.120.000 = 35.840.000$ Bit $\equiv 35,84$ Mb Speicherplatz. Die Zielplattform besitzt jedoch nur einen \ac{BRAM} von insgesamt $32,1$ Mb. Für das Beispielbild liegt die obere Grenze der zu durchsuchenden Radien bei 50. Der Bresenham Algorithmus für einen Kreis mit dem Radius von 50 erzeugt $4 \cdot \sqrt{2} \cdot 50 = 282,84 \approx 283$ Punkte. Diese können in neun Bit gespeichert werden: $2^9 = 512$. Über die \emph{Arbirary Precision Data Types Library} von Vivado kann das Feld mit einem neun Bit großem Datentyp realisiert werden. Der benötigte \ac{BRAM} beträgt dann: $9 \cdot 1.120.000 = 10.080.000$ Bit $\equiv 10,08$ Mb.
\\
Falls der \ac{BRAM} für größere Bilder nicht mehr ausreicht, kann der Akkumulator im \ac{RAM}, welcher dem FPGA zur Verfügung steht, gespeichert werden und über Linebuffer nur für die benötigten Zeilen im \ac{BRAM} gecached werden.
\\
\\
Zur weiteren Beschleunigung muss geschaut werden, an welchen Stellen Pipelining angewandt werden kann. Es gibt zwei große verschachtelte Schleifenblöcke.
\\
Der erste Block besteht aus drei verschachtelten For-Schleifen. Innerhalb der innersten For-Schleife ist noch eine While-Schleife enthalten. Dieser Block implementiert das Votingverfahren. Hier kann nur die innerste Schleife, die While-Schleife, gepipelined werden. Sie hat eine variable Anzahl an Iterationen und kann daher nicht unrolled werden. Für das Pipelining einer der äußeren Schleifen wäre dies jedoch notwendig. Innerhalb der While-Schleife wird acht mal hintereinander die \emph{vote} Methode aufgerufen. Dort wird das Akkumulatorfeld an den entsprechenden Stellen erhöht, sofern sie innerhalb der Bildgrenzen liegen. Vivado HLS erkennt nicht, dass auf verschiedene Indizes des Akkumulators zugegriffen wird und vermutet an dieser Stelle Datenabhängigkeiten. Mit der \emph{DEPENDENCE} Direktive können diese Abhängigkeiten als falsch gekennzeichnet werden. Damit kann das \ac{II} auf eins gebracht werden.
% TODO: acc muss partitioniert werden, um Anzahl der Zugriffe zu ermöglichen
\\
Der zweite Block ist in \autoref{lst:hough} dargestellt. Er filtert die höchsten Werte aus dem Akkumulator und findet dadurch die Kreise. Wenn ein Kreis gefunden wurde, muss der Akkumulator in der näheren Umgebung für alle Radien auf Null gesetzt werden. Diese Funktion wird durch drei For-Schleifen implementiert, welche in \autoref{lst:hough} an der Stelle von Z. 9 stehen.
% TODO: warum kann outer_clearing_loop trotz variablen bounds gepipelined werden?
\\
\\
Es stehen der \ac{PL} insgesamt 1.824 \acp{BRAM} zur Verfügung, von denen mit der oben beschriebenen Lösung nur $\frac{10.080 \; \text{Kb}}{18 \; \text{Kb}} = 560$ verwendet werden. %TODO: -> Partitionierung von acc für besseres II beim Pipelining
