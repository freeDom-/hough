Für die Synthese des \ac{CHT} Moduls müssen verschiedene Veränderungen gegenüber der Softwareimplementierung vorgenommen werden.
\\
\\
Als Interfaces für das Modul werden das 8 Bit breite Eingabefeld mit den Daten des Eingabebildes, das Ausgabefeld, welches die gefundenen Kreise enthält und ein Zeiger auf die Anzahl der gefundenen Kreise definiert. Das Ausgabefeld ist vom Datentyp \emph{struct circle}, welcher in \autoref{lst:circle} definiert wird.
\\
Das Eingabebild für das \ac{CHT} Modul ist ein binäres Gradientenbild. Es gibt also nur die Farben Weiß und Schwarz. Um die Größe zu des Feldes zu reduzieren, kann das Eingabefeld mit dem \emph{Arbitrary Precision Datatype uint1} [S. 246ff]\cite{vivado902ug} realisiert werden. In dieser Arbeit wurde die Optimierung allerdings nicht berücksichtigt.
\\
\\
Zunächst muss das Feld, welches die Votingmatrix der \ac{CHT} implementiert, betrachtet werden. Dies wurde in der Softwarelösung dynamisch allokiert und damit im Heap gespeichert. Auf dem FPGA sollte das Akkumulatorfeld für einen effektiven Zugriff im \ac{BRAM} gespeichert werden. Für ein Bild mit einer Größe von $400 \cdot 400$ Pixel und sieben zu durchsuchenden Radien benötigt der Akkumulator $400 \cdot 400 \cdot 7 = 1.120.000$ Elemente. In der Softwareimplementierung wurde das Feld als \emph{unsigned int} realisiert. Ein Element vom Datentyp \emph{unsigned int} hat auf der Zielarchitektur eine Größe von 32 Bit. Damit benötigt das Feld $32 \cdot 1.120.000 = 35.840.000$ Bit $\equiv 35,84$ Mb Speicherplatz. Die Zielplattform besitzt jedoch nur einen \ac{BRAM} von insgesamt $32,1$ Mb. Für das Beispielbild liegt die obere Grenze der zu durchsuchenden Radien bei 50. Der Bresenham Algorithmus für einen Kreis mit dem Radius von 50 erzeugt $4 \cdot \sqrt{2} \cdot 50 = 282,84 \approx 283$ Punkte. Diese können in neun Bit gespeichert werden: $2^9 = 512$. Über die \emph{Arbirary Precision Data Types Library} von Vivado kann das Feld mit einem neun Bit großem Datentyp realisiert werden. Der benötigte \ac{BRAM} beträgt dann: $9 \cdot 1.120.000 = 10.080.000$ Bit $\equiv 10,08$ Mb und das gesamte Feld passt in den \ac{BRAM}.
\\
Wenn der \ac{BRAM} nicht ausreicht, um das gesamte Akkumulatorfeld zu laden, kann der Akkumulator im für den \ac{FPGA} verfügbaren \ac{RAM} gespeichert werden. Über Puffer können dann die benötigten Zeilen rechtzeitig in den \ac{BRAM} geladen werden, sodass sie für einen schnellen Zugriff zur Verfügung stehen.
\\
\\
Zur weiteren Beschleunigung wird geprüft, an welchen Stellen Pipelining angewandt werden kann. Es gibt zwei große verschachtelte Schleifenblöcke, die in den folgenden Abschnitten betrachtet werden.
\nowidow

Der erste Block besteht aus drei verschachtelten For-Schleifen und einer While-Schleife. Dieser Block implementiert das Votingverfahren. Die Softwareimplementierung benötigt für diesen Block am meisten Zeit. Er sollte also auch bei der Optimierung im Vordergrund stehen. Hier kann nur die innerste Schleife, die While-Schleife, gepipelined werden. Sie hat eine variable Anzahl an Iterationen und kann daher nicht ausgerollt werden. Für das Pipelining einer der äußeren Schleifen wäre das Ausrollen aller inneren Schleifen jedoch, wie in \autoref{sec:synthese-und-optimierungen} erwähnt, eine notwendige Bedingung.
\\
Innerhalb der While-Schleife wird achtmal hintereinander die \emph{vote} Methode aufgerufen. Dort wird das Akkumulatorfeld an den entsprechenden Koordinaten erhöht, sofern sie innerhalb der Bildgrenzen liegen. Vivado HLS erkennt nicht, dass auf verschiedene Indizes des Akkumulators zugegriffen wird und vermutet an dieser Stelle Datenabhängigkeiten. Mit der \emph{DEPENDENCE} Direktive können diese Abhängigkeiten als falsch gekennzeichnet werden. Wenn nun zusätzlich das Akkumulatorfeld partitioniert wird, um die größere Menge an Zugriffen zu realisieren, kann das \ac{II} auf eins gebracht werden. Dazu muss eine zyklische Partitionierung mit dem Faktor acht vorgenommen werden.
\\
\\
Der zweite Block ist in \autoref{lst:hough} dargestellt. Er filtert die höchsten Werte aus dem Akkumulator, erhöht die Anzahl der gefundenen Kreise und fügt die gefundenen Kreise dem Ausgabefeld hinzu. Sobald ein Kreis gefunden wurde, muss der Akkumulator in der näheren Umgebung für alle Radien auf Null gesetzt werden. Diese Funktion wird durch drei For-Schleifen implementiert, welche in \autoref{lst:hough} Z. 9 angedeutet werden.
\\
Zum Pipelining der äußersten For-Schleife wird diese mit der mittleren Zusammengefasst, da beide variable Parameter enthalten. Die innerste For-Schleife kann ohne Probleme ausgerollt werden. Nach dem Unrolling finden sieben Zugriffe auf den Akkumulator statt. Im ersten Block wurde der Akkumulator bereits ausreichend partitioniert, sodass sieben parallele Zugriffe möglich sind. Damit kann auch für diese Schleife ein \ac{II} von eins erreicht werden.
\\
\\
Schließlich kann noch die For-Schleife, welche das Akkumulatorfeld mit Nullen initialisiert, gepipelined werden. Diese hat auch mit den bereits definierten Direktiven ein \ac{II} von eins. Zur schnelleren Verarbeitung kann die Schleife zusätzlich mit einem Faktor von 16 ausgerollt werden. Damit verringert sich die Anzahl der Iterationen und es werden 16 Akkumulatoreinträge gleichzeitig initialisiert. Wenn die Schleife noch weiter ausgerollt werden soll, muss auch die Partitionierung des Akkumulatorfeldes vergrößert werden, um mehr parallele Zugriffe zu ermöglichen.
\\
\\
Die Softwarelösung benötigt 1.044 ms zur Ausführung des \ac{CHT} Moduls. \autoref{tab:synthese_hough400x400} kann entnommen werden, dass eine Taktrate von 200 MHz realisierbar ist und das Modul damit nach der Synthese eine Laufzeit von 123,85 ms hat. Daraus folgt, dass ein Speedup von 8,43 gegenüber der Softwarelösung erzielt wird. Die Ressourcen des FPGA werden nur zu zehn Prozent genutzt. Dadurch können entweder noch andere Module der \ac{HT} neben diesem Modul beschleunigt werden oder weitere Optimierungen an diesem Modul vorgenommen werden. Dafür müssten jedoch Anpassungen am Code vorgenommen werden, sodass weitere Schleifen ausgerollt werden können.

\begin{table}[H]
	\centering
	\caption[Ergebnisse der Synthese für das Circle Hough Detection Modul]{Ergebnisse der Synthese für das \ac{CHT} Modul. In den Spalten stehen die verschiedenen Optimierungsschritte. Die prozentualen Angaben sind auf ganze Prozent gerundet.}
	\resizebox{\textwidth}{!}{
		\begin{tabular}{lrrrr}
			\toprule
			&  & \multicolumn{3}{c}{\textbf{Pipelining}} \\
			& \textbf{Keine} & \textbf{Bresenham-While} & \textbf{Clearing-For} & \textbf{Acc-Init-For} \\
			\toprule
			Zieltakt $[$ns$]$ & 5 & 5 & 5 & 5 \\
			Erw. Takt $[$ns$]$ & 4,62 & 4,8 & 4,8 & 4,8 \\
			Latenz $[$Takte$]$ & 105.552.579.200 & 50.346.485.074 & 26.940.112 & 24.770.112 \\
			Laufzeit Software $[$ms$]$ & 1.044,00 & 1.044,00 & 1.044,00 & 1.044,00 \\
			Laufzeit $[$ms$]$ & 527.762,90 & 251.732,43 & 134,70 & 123,85 \\
			\textbf{Speedup} & 0,002 & 0,004 & 7,75 & \textbf{8,43} \\
			\hline
			\acs{BRAM} & 681 (37\%) & 686 (37\%) & 686 (37\%) & 686 (37\%) \\
			\acs{DSP}48E & 6 (0\%) & 14 (1\%) & 19 (1\%) & 19 (1\%) \\
			\acs{FF} & 1.674 (0\%) & 3.035 (1\%) & 3.932 (1\%) & 3.911 (1\%) \\
			\acs{LUT} & 2.699 (1\%) & 6.588 (2\%) & 8.651 (3\%) & 8.764 (3\%) \\
			\textbf{FPGA-Ressourcen} & 10\% & 10\% & 11\% & \textbf{11}\% \\
			\textbf{Speedup $\div$ FPGA-Ress.} & 0,02 & 0,04 & 70,45 & \textbf{76,74} \\
			\bottomrule
		\end{tabular}
	}
	\label{tab:synthese_hough400x400}
\end{table}
