Für die Auslagerung der Komponenten auf die \ac{PL} müssen diese zunächst in Hardware umgewandelt werden. Die im vorigen Kapitel vorgestellten Softwareimplementierungen werden dazu mittels Vivado HLS zu einem \ac{RTL} synthetisiert. Anschließend wird das \ac{RTL} über eine C/\ac{RTL} Cosimulation verifiziert und kann schließlich als \ac{IP} in Vivado zum Hardware/Software Codesign verwendet werden. Bei der Synthese werden bereits approximierte Daten bezüglich der Laufzeit und den benötigten Ressourcen erzeugt. Die erzeugten Daten bieten einen ersten Anhaltspunkt für die weitere Optimierung.
\\
\\
Die Module sollen im Hardware/Software Codesign verwendet werden, also nicht als eigenständige Hardwarelösung zum Einsatz kommen. Daher müssen im ersten Schritt der Synthese die Interfaces definiert werden. Dies geschieht in Vivado HLS durch setzen der Interface-Direktive für die jeweiligen Argumente der Funktion. Für das Codesign wird \ac{AXI4} verwendet. Die Argumente, welche eine sequentielle Verarbeitung der Daten zulassen, sollten zudem als Stream implementiert werden. Dies führt zu Designs, die eine bessere Performance haben und weniger Ressourcen benötigen. \cite[S. 113ff]{vivado902ug}
\\
\\
Die Optimierung findet in zwei Schritten statt: Zuerst wird die Laufzeit minimiert. Dies geschieht vor allem durch Pipelining von Schleifen und Funktionen sowie durch Loop unrolling. Loop unrolling bezeichnet das Zusammenfassen von allen Iterationsschritten einer Schleife zu einem einzigen Schritt. Loop unrolling stellt für das Pipelining einer äußeren Schleife eine notwendige Bedingung dar. Allerdings führt Loop unrolling auch zu einem hohen Ressourcenverbrauch. Der Kompromiss zwischen Laufzeitersparnis und erhöhtem Hardwareaufwand muss in jedem Fall einzeln betrachtet werden.
\cite[S. 188-209]{vivado902ug}
\\
\\
Wenn die Laufzeit zufriedenstellend optimiert wurde und keine weiteren Verbesserungen mehr erzielt werden können, kann das Design hinsichtlich des Ressourcenverbrauchs optimiert werden. Hierbei können vor allem durch Datenflussdirektiven oder durch Zusammenfassen mehrerer kleiner Felder zu einem großen Feld (Array Mapping) Verbesserungen erzielt werden.
\cite[S. 210-219]{vivado902ug}

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.8\linewidth]{Bilder/arm_laufzeit400x400.png}
	\caption{Laufzeit der \ac{HT} für ein 400x400 Pixel großes Bild auf dem Cortex-A53}
	\label{img:arm_laufzeit400x400}
\end{figure}

Aus \autoref{img:arm_laufzeit400x400} geht hervor, dass durch die Parallelisierung bereits eine ungefähr 2,5-fache Laufzeitbeschleunigung erzielt werden kann. Darüber hinaus kann der Grafik entnommen werden, dass das Modul für die \ac{CHT} eindeutig am meisten Zeit benötigt. Das Modul für die Canny Edge Detection ist nach der \ac{CHT} das langsamste Modul, aber mit einer Laufzeit von 81ms immer noch ungefähr 13-mal schneller als die \ac{CHT}. Daher soll der Fokus für die Optimierung und Auslagerung in die Hardware auf das \ac{CHT} Modul gelegt werden. In den folgenden Kapiteln wird die \ac{HLS} zunächst als einleitendes Beispiel für das Grayscaler Modul und anschließend für das \ac{CHT} Modul durchgeführt.
