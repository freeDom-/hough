Als Interfaces für den Grayscaler dienen die Felder, welche Ein- und Ausgabedaten enthalten. Als einzige Anpassung am Code sollte die Berechnung des Intensitätswertes auf eine ganzzahlbasierte Berechnung geändert werden.

\begin{equation}
output[index] = (30*r + 59*g + 11*b)/100
\end{equation}

Hierdurch verringert sich zwar die Präzision minimal, allerdings beträgt die Abweichung am Intensitätswert höchstens 1 von der alten Berechnungsmethode. Dies ist in dem erzeugten Bild kaum erkennbar und spielt für die weitere Verarbeitung keine Rolle. Der Ressourcenverbrauch sinkt allerdings wie in \autoref{img:synthese_grayscaler400x400} zu sehen von 2.012 benötigten \acp{FF} und 2.948 \acp{LUT} auf 103 benötigte \acp{FF} und 189 \acp{LUT}. Zusätzlich wird die Anzahl der benötigten Takte um einen Faktor von ungefähr 7 auf 480.801 Takte reduziert.

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.8\linewidth]{Bilder/synthese_grayscaler400x400.png}
	\caption{Ergebnisse der Synthese für das Grayscalermodul bei einem 400x400 Pixel großen Bild}
	\label{img:synthese_grayscaler400x400}
\end{figure}

Bei einem Pipelining der inneren Schleife kann ein Bild der Größe $hoehe \cdot breite$ in $hoehe \cdot breite$ Takten verarbeitet werden. Bei einem Bild der Größe $400x400$ entspricht das $160.000$ Takten. Für das Pipelining der äußeren Schleife muss die innere Schleife unrolled werden. Dies führt dazu, dass beim Pipelining $breite$ mal gleichzeitig auf das Feld $input$ zugegriffen wird. Dieses wird allerdings entweder als \ac{BRAM}, welcher nur 2 Zugriffe gleichzeitig ermöglicht, oder als AXI4-Stream realisiert. Bei einem Stream kann sogar nur ein Zugriff pro Takt erfolgen, weshalb in diesem Fall äußere Schleife nicht gepipelined werden kann. Das Feld könnte durch mehrere kleinere \acp{BRAM} realisiert werden. Das Grayscalermodul läuft bereits in der Softwarelösung sehr schnell und der zusätzliche Hardwareaufwand lohnt sich daher in diesem Fall nicht. Das Pipelining der inneren Schleife bringt zwar nur einen geringeren Performanceboost, benötigt allerdings auch deutlich weniger Ressourcen.
\\
\\
\autoref{img:synthese_grayscaler400x400} zeigt, dass die \ac{PL} ungefähr 160.003 Takte beim Pipelining der inneren Schleife und 80.003 Takte beim Pipelining der äußeren Schleife benötigt. Bei einer Taktrate von 200 MHz, die als realisierbar betrachtet werden kann, wird nach der Synthese eine Laufzeit von 0,8ms bzw. 0,4ms und damit bereits ein Speedup von 5 bzw. 10 erzielt.
\\
\\
In \autoref{img:implementierung_grayscaler400x400} sieht man, dass die von der Synthese berechneten Werte auch nach der Implementierung eingehalten werden können. Sowohl der Platzbedarf als auch das Timing liegen in einem zufriedenstellenden Bereich.

\begin{figure}[htb]
	\centering
%	\includegraphics[width=0.8\linewidth]{Bilder/implementierung_grayscaler400x400.png}
	\caption{Ergebnisse der Implementierung für das Grayscalermodul bei einem 400x400 Pixel großen Bild}
	\label{img:implementierung_grayscaler400x400}
\end{figure}
