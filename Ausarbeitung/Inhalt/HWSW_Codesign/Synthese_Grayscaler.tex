Das Grayscaler Modul besitzt die geringste Laufzeit von allen Modulen und ist daher aus praktischer Sicht keine gute Wahl für eine \ac{HLS}. Die Synthese des Grayscaler Moduls gestaltet sich jedoch vergleichsweise sehr einfach und dient daher als gutes Beispiel, um die grundlegenden Methoden der \ac{HLS} zu zeigen.
\\
\\
Als Interfaces für den Grayscaler werden das 32 Bit breite Eingabe- und das 8 Bit breite Ausgabefeld definiert. Es empfiehlt sich als einzige Anpassung am Code, die Berechnung des Intensitätswertes auf eine ganzzahlbasierte Berechnung zu verändern.

\begin{equation}
output[index] = (30*r + 59*g + 11*b)/100
\end{equation}

Hierdurch verringert sich zwar die Präzision minimal, allerdings beträgt die Abweichung des Intensitätswertes höchstens 1 im Vergleich zur alten Berechnungsmethode. Dies ist in dem erzeugten Bild nicht erkennbar und spielt für die weitere Verarbeitung keine Rolle. Entscheidend ist, wie in \autoref{img:synthese_grayscaler400x400} zu sehen, dass der Ressourcenverbrauch von 2.837 benötigten \acp{FF} und 3.017 \acp{LUT} auf 136 benötigte \acp{FF} und 194 \acp{LUT} sinkt. Zusätzlich wird die Anzahl der benötigten Takte um einen Faktor von circa 8,2 auf 640.801 Takte reduziert.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{Bilder/synthese_grayscaler400x400.png}
	\caption[Ergebnisse der Synthese des Grayscalermoduls]{Ergebnisse der Synthese des Grayscalermodul bei einem 400x400 Pixel großen Bild. Erzeugt mit Vivado HLS 2017.4 \cite{vivado902ug}}
	\label{img:synthese_grayscaler400x400}
\end{figure}

Um das Modul weiter zu beschleunigen, können im Anschluss die Schleifen gepipelined werden.
\\
Beim Pipelining der inneren Schleife beträgt das \ac{II} eins. Daher kann sie für ein Bild der Größe $hoehe \cdot breite$ in $hoehe \cdot breite$ Takten ausgeführt werden. Demnach kann ein Bild der Größe $400 \cdot 400$ in circa $160.000$ Takten verarbeitet werden.
\\
Um die äußere Schleife pipelinen zu können, muss die innere Schleife zunächst unrolled werden. Dies führt dazu, dass beim Pipelining $breite$-mal gleichzeitig auf das Feld $input$ zugegriffen wird. Das Feld befindet sich allerdings in einem \ac{BRAM}, welcher nur einen Lese- und einen Schreibzugriff pro Takt ermöglicht. Für das Pipelining der äußeren Schleife ist es deshalb zusätzlich notwendig, das Eingabe- und Ausgabefeld mit einem Faktor von $breite$ zyklisch zu partitionieren, um ein \ac{II} von eins zu erzielen. Damit kann ein Bild in circa $hoehe$ Takten verarbeitet werden. Das entspricht $400$ Takten für ein Bild der Größe $400 \cdot 400$.
\\
\\
Um die Fläche zu optimieren, wurde der Versuch unternommen den \ac{BRAM} für das Ein- und Ausgabefeld als \ac{BRAM} zu realisieren, welcher zwei Schreib- oder Leseoperationen pro Takt ermöglicht. Dann können das Eingabe- und Ausgabefeld mit einem Faktor von $\frac{breite}{2}$ partitioniert werden. Hierfür wurde die Direktive \emph{HLS\_RESSOURCE} mit dem Parameter \emph{core=RAM\_T2P\_BRAM} angegeben. %TODO: warum funktioniert es nicht?
\\
\\
\autoref{img:synthese_grayscaler400x400} zeigt, dass die \ac{PL} geschätzt 160.005 Takte nach dem Pipelining der inneren Schleife benötigt. Bei einer Taktrate von 200 MHz, die als realisierbar betrachtet werden kann, wird nach der Synthese eine Laufzeit von 0,8 ms und damit ein Speedup von 5 erzielt.
\\
Nach dem Pipelining der äußeren Schleife werden geschätzt 404 Takte benötigt. Bei einer Taktrate von 200 MHz, welche auch für diesen Fall als realisierbar geschätzt wird, wird eine Laufzeit von 0,002 ms und damit ein Speedup von 2000 erzielt. Es fällt außerdem auf, dass der Ressourcenverbrauch unverhältnismäßig gestiegen ist. Im Vergleich zur Lösung mit Pipelining der inneren Schleife ist die Anzahl der benötigten \acp{FF} um einen Faktor von etwa 180, die Anzahl der benötigten \acp{DSP} um einen Faktor von 300 und die Anzahl der benötigten \acp{LUT} um einen Faktor von circa 139 gestiegen. Der Verbrauch des \acp{BRAM} ist außerdem auf fast 100\% des vorhandenen \acp{BRAM} angestiegen. Dies zeigt gut die Möglichkeiten der \ac{HLS} auf. An dieser Stelle ist der hohe Speedup im Vergleich zu dem deutlich erhöhten Ressourcenverbrauch allerdings nicht gerechtfertigt. Das Modul ist bereits schnell genug und die Ressourcen sollten zur Beschleunigung der gesamten \ac{HT} besser an anderer Stelle investiert werden.
