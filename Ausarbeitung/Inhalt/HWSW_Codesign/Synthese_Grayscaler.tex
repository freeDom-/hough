Das Grayscaler Modul besitzt die geringste Laufzeit von allen Modulen und ist daher aus praktischer Sicht keine gute Wahl für eine \ac{HLS}. Die Synthese des Grayscaler Moduls gestaltet sich jedoch vergleichsweise sehr einfach und dient daher als gutes Beispiel, um die grundlegenden Methoden der \ac{HLS} zu zeigen.
\\
\\
Als Interfaces für den Grayscaler werden das 32 Bit breite Eingabe- und das 8 Bit breite Ausgabefeld definiert. Es empfiehlt sich als einzige Anpassung am Code, die Berechnung des Intensitätswertes auf eine ganzzahlbasierte Berechnung zu verändern.

\begin{equation}
output[index] = (30*r + 59*g + 11*b)/100
\end{equation}

Hierdurch verringert sich zwar die Präzision minimal, allerdings beträgt die Abweichung des Intensitätswertes höchstens 1 im Vergleich zur alten Berechnungsmethode. Dies ist in dem erzeugten Bild nicht erkennbar und spielt für die weitere Verarbeitung keine Rolle. Entscheidend ist, wie in \autoref{tab:synthese_grayscaler400x400} zu sehen, dass die Anzahl der benötigten Takte um einen Faktor von circa 8,2 auf 640.801 Takte reduziert. Außerdem erkennt man, dass neun Prozent der Gesamtressourcen verbraucht werden. Das Resultat ist zufriedenstellend.
\\
\\
Um das Modul weiter zu beschleunigen, können im Anschluss die Schleifen gepipelined werden.
\\
Beim Pipelining der inneren Schleife beträgt das \ac{II} eins. Daher kann sie für ein Bild der Größe $hoehe \cdot breite$ in $hoehe \cdot breite$ Takten ausgeführt werden. Ein Bild der Größe $400 \cdot 400$ kann demnach in circa $160.000$ Takten verarbeitet werden.
\\
Um die äußere Schleife pipelinen zu können, muss die innere Schleife zunächst unrolled werden. Dies führt dazu, dass beim Pipelining $breite$-mal gleichzeitig auf das Feld $input$ zugegriffen wird. Das Feld befindet sich allerdings in einem \ac{BRAM}, welcher nur einen Lese- und einen Schreibzugriff pro Takt ermöglicht. Für das Pipelining der äußeren Schleife ist es deshalb zusätzlich notwendig, das Eingabe- und Ausgabefeld mit einem Faktor von $breite$ zyklisch zu partitionieren, um ein \ac{II} von eins zu erzielen. Damit kann ein Bild in circa $hoehe$ Takten verarbeitet werden. Das entspricht $400$ Takten für ein Bild der Größe $400 \cdot 400$.
\\
\\
Um die Fläche zu optimieren, kann der \ac{BRAM} für das Ein- und Ausgabefeld als Dual-Port-\ac{BRAM} realisiert werden, welcher zwei Schreib- oder Leseoperationen pro Takt ermöglicht. Im Rahmen dieser Arbeit wurde diese Optimierung allerdings nicht berücksichtigt.

\begin{table}[H]
	\centering
	\caption[Ergebnisse der Synthese des Grayscalermoduls]{Ergebnisse der Synthese des Grayscalermoduls. In den Spalten stehen die verschiedenen Optimierungsschritte. Die prozentualen Angaben sind auf ganze Prozent gerundet.}
	\resizebox{\textwidth}{!}{
		\begin{tabular}{lrrrr}
			\toprule
			&  &  & \multicolumn{2}{c}{\textbf{Pipelining}} \\
			& \textbf{Keine} & \textbf{Int.-Berechnung} & \textbf{innere Schleife} & \textbf{äußere Schleife} \\
			\toprule
			Zieltakt $[$ns$]$ & 5 & 5 & 5 & 5 \\
			Erw. Takt $[$ns$]$ & 4,06 & 3,71 & 3,71 & 3,68 \\
			Latenz $[$Takte$]$ & 5.280.801 & 640.801 & 160.005 & 404 \\
			Laufzeit Software $[$ms$]$ & 4 & 4 & 4 & 4 \\
			Laufzeit $[$ms$]$ & 26,40 & 3,2 & 0,8 & 0,002 \\
			\textbf{Speedup} & 0,15 & 1,25 & \textbf{5} & \textbf{2.000} \\
			\hline
			BRAM & 0 (0\%) & 640 (35\%) & 640 (35\%) & 1.600 (88\%) \\
			DSP48E & 25 (1\%) & 3 (0\%) & 4 (0\%) & 1.200 (48\%) \\
			FF & 2.837 (1\%) & 332 (0\%) & 445 (0\%) & 80.190 (15\%) \\
			LUT & 3.017 (1\%) & 374 (0\%) & 466 (0\%) & 64.599 (24\%) \\
			\textbf{FPGA-Ressourcen} & 1\% & 9\% & \textbf{9\%} & \textbf{44\%} \\
			{$\textbf{Speedup $\div$ FPGA-Ress.}$} & 15 & 13,89 & \textbf{55,56} & \textbf{4.545,45} \\
			\bottomrule
		\end{tabular}
	}
	\label{tab:synthese_grayscaler400x400}
\end{table}

\autoref{tab:synthese_grayscaler400x400} zeigt, dass das Pipelining der inneren Schleife nahezu keine Ressourcen kostet und einen erheblichen Geschwindigkeitsvorteil erbringt. Die Laufzeit der Softwareimplementierung lag für den Grayscaler bei 4 ms. Bei einer Taktrate von 200 MHz, welche 5 ns Taktzeit entspricht, wird nach der Synthese eine Laufzeit von 0,8 ms und damit ein Speedup von 5 erzielt.
\\
Für das Pipelining der äußeren Schleife werden zwar 44\% der Gesamtressourcen benötigt, allerdings wird damit auch ein Speedup von 2.000 erreicht. Die Taktrate von 200 MHz wird auch für diesen Fall als realisierbar geschätzt. Es ergibt sich eine Laufzeit von 0,002 ms und damit ein Speedup von 2000. Dementsprechend ist auch ein Anstieg des Ressourcenverbrauchs zu verzeichnen. Im Vergleich zur Lösung mit Pipelining der inneren Schleife ist die Anzahl der benötigten \acp{FF} um einen Faktor von etwa 180, die Anzahl der benötigten \acp{DSP} um einen Faktor von 300 und die Anzahl der benötigten \acp{LUT} um einen Faktor von circa 139 gestiegen. Der Verbrauch des \acp{BRAM} ist außerdem auf 88\% des vorhandenen \acp{BRAM} angestiegen. Für größere Bilder wird die Größe des \ac{BRAM} ein begrenzender Faktor sein.
\\
Das Ergebnis zeigt gut die Möglichkeiten der \ac{HLS} auf. An dieser Stelle ist der hohe Speedup anlässlich des deutlich erhöhten Ressourcenverbrauch allerdings nicht mehr notwendig. Das Modul ist bereits schnell genug und die Ressourcen sollten zur Beschleunigung der gesamten \ac{HT} besser an anderer Stelle investiert werden.
